# -*- coding: utf-8 -*-
"""Neural_style_transfer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/131URLJA1vWgl-eJTn-NWO18W9Qq3YfCT
"""

import torch
import torchvision
from torch import nn
import PIL
import matplotlib.pyplot as plt
import numpy as np
# from IPython.display import clear_output
import cv2

rgb_mean = torch.tensor([0.485, 0.456, 0.406])
rgb_std = torch.tensor([0.229, 0.224, 0.225])

def preprocess(img, image_shape):
    transforms = torchvision.transforms.Compose([
        torchvision.transforms.Resize(image_shape, antialias=True),
        torchvision.transforms.ToTensor(),
        torchvision.transforms.Normalize(mean=rgb_mean, std=rgb_std)])
    return transforms(img).unsqueeze(0)

def postprocess(img):
    img = img[0].to(rgb_std.device)
    img = torch.clamp(torch.permute(img, (1, 2, 0)) * rgb_std + rgb_mean, 0, 1).detach().cpu().numpy()
    return img

pretrained_net = torchvision.models.vgg19(weights=torchvision.models.VGG19_Weights.DEFAULT)

style_layers, content_layers = [0, 5, 10, 19, 28], [25]
net = nn.Sequential(*[pretrained_net.features[i] for i in
                      range(max(content_layers + style_layers) + 1)])

def extract_features(X, content_layers, style_layers):
    contents = []
    styles = []
    for i in range(len(net)):
        X = net[i](X)
        if i in style_layers:
            styles.append(X)
        if i in content_layers:
            contents.append(X)
    return contents, styles

def get_contents(content_img, image_shape, device):
    content_X = preprocess(content_img, image_shape).to(device)
    contents_Y, _ = extract_features(content_X, content_layers, style_layers)
    return content_X, contents_Y

def get_styles(style_img, image_shape, device):
    style_X = preprocess(style_img, image_shape).to(device)
    _, styles_Y = extract_features(style_X, content_layers, style_layers)
    return style_X, styles_Y

#LOSS

def content_loss(Y_hat, Y):
    return torch.square(Y_hat - Y.detach()).mean()

def gram(X):
    num_channels, n = X.shape[1], X.numel() // X.shape[1]
    X = X.reshape((num_channels, n))
    return torch.matmul(X, X.T) / (num_channels * n)

def style_loss(Y_hat, gram_Y):
    return torch.square(gram(Y_hat) - gram_Y.detach()).mean()

def tv_loss(Y_hat):
    return 0.5 * (torch.abs(Y_hat[:, :, 1:, :] - Y_hat[:, :, :-1, :]).mean() +
                  torch.abs(Y_hat[:, :, :, 1:] - Y_hat[:, :, :, :-1]).mean())



def compute_loss(X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram):
    # Calculate the content, style, and total variance losses respectively
    contents_l = [content_loss(Y_hat, Y) * content_weight for Y_hat, Y in zip(
        contents_Y_hat, contents_Y)]
    styles_l = [style_loss(Y_hat, Y) * style_weight for Y_hat, Y in zip(
        styles_Y_hat, styles_Y_gram)]
    tv_l = tv_loss(X) * tv_weight
    # Add up all the losses
    l = sum(styles_l + contents_l + [tv_l])
    return contents_l, styles_l, tv_l, l



class SynthesizedImage(nn.Module):
    def __init__(self, img_shape, **kwargs):
        super(SynthesizedImage, self).__init__(**kwargs)
        self.weight = nn.Parameter(torch.rand(*img_shape))

    def forward(self):
        return self.weight

def get_inits(X, device, lr, styles_Y):
    gen_img = SynthesizedImage(X.shape).to(device)
    gen_img.weight.data.copy_(X.data)
    optimizer = torch.optim.LBFGS(gen_img.parameters(), max_iter=50, line_search_fn='strong_wolfe')
    styles_Y_gram = [gram(Y) for Y in styles_Y]
    return gen_img(), styles_Y_gram, optimizer

device = 'cuda'
content_img = PIL.Image.open('khalij_1.jpg')
style_img = PIL.Image.open('Van_Gogh_Starry_Night.jpg')
image_shape = (1020, 1360)
net = net.to(device)
lr, num_epochs, lr_decay_epochs = 0.2, 25000, 40
content_weight, style_weight, tv_weight = 1, 1e4, 1

content_X, contents_Y = get_contents(content_img, image_shape, device)
_, styles_Y = get_styles(style_img, image_shape, device)

#TRAINING

X, styles_Y_gram, optimizer = get_inits(content_X, device, lr, styles_Y)
# scheduler = torch.optim.lr_scheduler.StepLR(optimizer, lr_decay_epochs, gamma=0.5)

contents_l_history = []
styles_l_history = []
tv_l_history = []


for epoch in range(1, num_epochs+1):

    def closure():

        optimizer.zero_grad()
        contents_Y_hat, styles_Y_hat = extract_features(
                X, content_layers, style_layers)
        contents_l, styles_l, tv_l, l = compute_loss(
                X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)
        l.backward()
        contents_l_history.append(float(sum(contents_l)))
        styles_l_history.append(float(sum(styles_l)))
        tv_l_history.append(float(tv_l))
        return l
    optimizer.step(closure)
    # scheduler.step()


    if (epoch)%1 == 0:
        # clear_output()
        plt.figure(figsize=(15,8))
        plt.subplot(1,2,1)
        plt.plot(np.arange(1,epoch+1), contents_l_history)
        plt.plot(np.arange(1,epoch+1), styles_l_history)
        plt.plot(np.arange(1,epoch+1), tv_l_history)
        plt.legend(['content', 'style', 'TV'])

        plt.subplot(1,2,2)
        plt.imshow(postprocess(X))
        plt.show(block=False)

output_filename = "output_image.jpg"
cv2.imwrite(output_filename, cv2.cvtColor((postprocess(X) * 255).astype(np.uint8), cv2.COLOR_RGB2BGR))